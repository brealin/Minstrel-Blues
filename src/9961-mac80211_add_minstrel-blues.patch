--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -50,10 +50,14 @@ mac80211-$(CONFIG_PM) += pm.o
 
 CFLAGS_trace.o := -I$(src)
 
-rc80211_minstrel-y := rc80211_minstrel.o
+rc80211_minstrel-y := \
+	rc80211_minstrel.o \
+	tpc80211_blues.o \
+	common.o
 rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_debugfs.o
 
-rc80211_minstrel_ht-y := rc80211_minstrel_ht.o
+rc80211_minstrel_ht-y := rc80211_minstrel_ht.o \
+		common.o
 rc80211_minstrel_ht-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_ht_debugfs.o
 
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
--- /dev/null
+++ b/net/mac80211/tpc80211_blues.c
@@ -0,0 +1,656 @@
+/*
+ * Transmit Power Control (TPC) algorithm "MINSTREL-BLUES".
+ * ________________________________________________________________________
+ * A decentralized joint power and rate controller that maximizes the weighted
+ * utility of achievable throughput and interference. Power and rate per link
+ * (per packet) are controlled to replace current static tx power usage. The
+ * goal is to increase overall WiFi network performance by increasing spatial
+ * reuse and hence allow more active links to communicate in parallel. Hence
+ * shared spectrum is used more efficiently by avoiding unnecessary
+ * interference through dynamic joint power and rate control.
+ *
+ * Copyright (C) 2016  Thomas Huehn <thomas@net.t-labs.tu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include "tpc80211_blues.h"
+
+/* lookup table to transform dBm [-20...39] in uW [10 .. 7940000] */
+static const u16 dBm2uW[10] = {1000, 1259, 1585, 1995, 2512, 3162, 3981, 5012,
+			       6310, 7943};
+
+/* convert dBm into mirco Watt (uW) to antilog tx power values */
+static unsigned int
+convert_dBm_to_uW(s8 power_dBm)
+{
+	u32 power_uW;
+
+	WARN_ON_ONCE(power_dBm < -20 || power_dBm >= 40);
+
+	if ((power_dBm >= -20) && (power_dBm < - 10))
+		power_uW = dBm2uW[power_dBm + 20] / 100;
+	else if (power_dBm < 0)
+		power_uW = dBm2uW[power_dBm + 10] / 10;
+	else if (power_dBm < 10)
+		power_uW = dBm2uW[power_dBm];
+	else if (power_dBm < 20)
+		power_uW = dBm2uW[power_dBm - 10] * 10;
+	else if (power_dBm < 30)
+		power_uW = dBm2uW[power_dBm - 20] * 100;
+	else if (power_dBm < 40)
+		power_uW = dBm2uW[power_dBm - 30] * 1000;
+	else
+		power_uW = 1000;
+
+	return power_uW;
+}
+
+/* Calculate EWMA of success probabilities */
+static void
+blues_calc_ewma(struct minstrel_rate *mr, u32 flags)
+{
+	struct blues_tpc_stats *mts = &mr->tpc_stats;
+	u32 success_ratio;
+
+	/* update data power stats */
+	if (flags & EWMA_DATA_POWER) {
+		success_ratio = MINSTREL_FRAC(mts->data_success,
+					      mts->data_attempts);
+		mts->data_prob = minstrel_ewma(mts->data_prob,
+					       success_ratio,
+					       EWMA_LEVEL);
+		mts->data_success = 0;
+		mts->data_attempts = 0;
+	}
+
+	/* update sample power stats */
+	if (flags & EWMA_SAMPLE_POWER) {
+		success_ratio = MINSTREL_FRAC(mts->sample_success,
+					      mts->sample_attempts);
+		mts->sample_prob = minstrel_ewma(mts->sample_prob,
+						 success_ratio,
+						 EWMA_LEVEL);
+		mts->sample_success = 0;
+		mts->sample_attempts = 0;
+	}
+
+	/* update ref power stats */
+	if (flags & EWMA_REF_POWER) {
+		success_ratio = MINSTREL_FRAC(mts->reference_success,
+					      mts->reference_attempts);
+		mts->reference_prob = minstrel_ewma(mts->reference_prob,
+						    success_ratio,
+						    EWMA_LEVEL);
+		mts->reference_success = 0;
+		mts->reference_attempts = 0;
+	}
+}
+
+/* Reset all Blues statistics */
+void
+blues_reset_stats(struct minstrel_rate *mr)
+{
+	mr->tpc_stats.reference_prob = MINSTREL_FRAC(TPC_INIT_REF_PROB, 100);
+	mr->tpc_stats.reference_success = 0;
+	mr->tpc_stats.reference_attempts = 0;
+	mr->tpc_stats.data_prob = MINSTREL_FRAC(TPC_INIT_DATA_PROB, 100);
+	mr->tpc_stats.data_success = 0;
+	mr->tpc_stats.data_attempts = 0;
+	mr->tpc_stats.sample_prob = MINSTREL_FRAC(TPC_INIT_SAMPLE_PROB, 100);
+	mr->tpc_stats.sample_success = 0;
+	mr->tpc_stats.sample_attempts = 0;
+	mr->tpc_stats.stats_outdated = 10;
+}
+
+/* Reset all Blues_ht statistics */
+void
+blues_ht_reset_stats(struct minstrel_ht_sta *mi, int group, int rate)
+{
+	struct blues_tpc_stats *tpc_stats;
+
+	tpc_stats = &mi->groups[group].tpc_stats[rate];
+	tpc_stats->reference_prob = MINSTREL_FRAC(TPC_INIT_REF_PROB, 100);
+	tpc_stats->reference_success = 0;
+	tpc_stats->reference_attempts = 0;
+	tpc_stats->data_prob = MINSTREL_FRAC(TPC_INIT_DATA_PROB, 100);
+	tpc_stats->data_success = 0;
+	tpc_stats->data_attempts = 0;
+	tpc_stats->sample_prob = MINSTREL_FRAC(TPC_INIT_SAMPLE_PROB, 100);
+	tpc_stats->sample_success = 0;
+	tpc_stats->sample_attempts = 0;
+	tpc_stats->stats_outdated = 10;
+}
+
+/* Initialize or reset all Blues power-levels */
+void
+blues_reset_power(struct minstrel_priv *mp, struct minstrel_rate *mr)
+{
+	struct ieee80211_hw *hw = mp->hw;
+	s8 max_power_level = hw->conf.power_level;
+	s8 min_power_level = hw->min_txpower;
+
+	mr->tpc_stats.reference_power = max_power_level;
+	mr->tpc_stats.sample_power = max_power_level;
+	if (mr->tpc_stats.sample_power > min_power_level + TPC_SAMPLE_POWER_SPAN)
+		mr->tpc_stats.sample_power -= TPC_SAMPLE_POWER_SPAN;
+	else
+		mr->tpc_stats.sample_power = min_power_level;
+	// printk(KERN_ERR "blues_reset_power called for bitrate: %i.%i\n",
+	// mr->bitrate / 2, mr->bitrate % 2 ? 5 : 0);
+}
+
+/* Initialize or reset all Blues_ht power-levels */
+void
+blues_ht_reset_power(struct minstrel_ht_sta *mi, struct ieee80211_hw *hw,
+		     int group, int rate)
+{
+	s8 max_power = hw->conf.power_level;
+	s8 min_power = hw->min_txpower;
+
+	mi->groups[group].tpc_stats[rate].reference_power = max_power;
+	mi->groups[group].tpc_stats[rate].sample_power = max_power;
+	if (mi->groups[group].tpc_stats[rate].sample_power > min_power +
+							TPC_SAMPLE_POWER_SPAN)
+		mi->groups[group].tpc_stats[rate].sample_power -=
+							TPC_SAMPLE_POWER_SPAN;
+	else
+		mi->groups[group].tpc_stats[rate].sample_power = min_power;
+}
+
+void
+blues_ht_tpc_init(struct minstrel_priv *mp, struct minstrel_ht_sta_priv *msp)
+{
+	struct ieee80211_hw *hw = mp->hw;
+	struct minstrel_ht_sta *mi = &msp->ht;
+	struct blues_tpc_stats *tpc_stats;
+	int group, rate;
+
+	/* Blues tpc initialization per STA */
+	mi->tpc_measuring_point = 1;
+	mi->tpc_ack_txpower = hw->conf.ack_txpower;
+
+	/* Blues tpc initialization per rate */
+	for (group = 0; group < ARRAY_SIZE(mi->groups); group++) {
+		for (rate = 0; rate < MCS_GROUP_RATES; rate++) {
+			blues_ht_reset_power(mi, hw, group, rate);
+			tpc_stats = &mi->groups[group].tpc_stats[rate];
+			tpc_stats->reference_prob = MINSTREL_FRAC(TPC_INIT_REF_PROB, 100);
+			tpc_stats->data_prob = MINSTREL_FRAC(TPC_INIT_DATA_PROB, 100);
+			tpc_stats->sample_prob = MINSTREL_FRAC(TPC_INIT_SAMPLE_PROB, 100);
+			tpc_stats->stats_outdated = 10;
+		}
+	}
+}
+
+/* trigger power level change of ack packets */
+int
+blues_set_ack_power(struct ieee80211_hw *hw, s8 val)
+{
+	hw->conf.ack_txpower = val;
+	drv_config(hw_to_local(hw), IEEE80211_CONF_CHANGE_ACK_TXPOWER);
+	return 0;
+}
+
+/* ensure that tx power levels are between max & min power level borders */
+static void
+blues_validate_power_level(struct minstrel_priv *mp, struct minstrel_rate *mr)
+{
+	struct blues_tpc_stats *mts = &mr->tpc_stats;
+	struct ieee80211_hw *hw = mp->hw;
+	s8 max_power = hw->conf.power_level;
+	s8 min_power = hw->min_txpower;
+
+	/* validate ref power level */
+	if (mts->reference_power > max_power)
+		mts->reference_power = max_power;
+	if (mts->reference_power < min_power + TPC_SAMPLE_POWER_SPAN)
+		mts->reference_power = min_power + TPC_SAMPLE_POWER_SPAN;
+
+	/* validate sample power level */
+	if (mts->sample_power > mts->reference_power - TPC_SAMPLE_POWER_SPAN)
+		mts->sample_power = mts->reference_power - TPC_SAMPLE_POWER_SPAN;
+	else if (mts->sample_power < min_power)
+		mts->sample_power = min_power;
+}
+
+static void
+blues_adjust_power_levels(struct minstrel_rate *mr)
+{
+	struct blues_tpc_stats *mts = &mr->tpc_stats;
+	u16 tpc_decrease_prob, tpc_increase_prob;
+	u16 valid_ref_prob, invalid_ref_prob;
+
+	/* adjust sample power level */
+	tpc_decrease_prob = tpc_increase_prob = mts->sample_prob;
+	tpc_decrease_prob += MINSTREL_FRAC(TPC_DECREASE_PROB_THRESH, 100);
+	tpc_increase_prob += MINSTREL_FRAC(TPC_INCREASE_PROB_THRESH, 100);
+
+	if (tpc_decrease_prob >= mts->reference_prob)
+		mts->sample_power -= TPC_MIN_POWER_DECREMENT;
+	// TODO (what if data is not sampled ???):
+	//else if (mr->tpc_reference_prob > mr->tpc_data_prob + MINSTREL_FRAC(TPC_BOOST_POWER_THRESH, 100))
+	else if (tpc_increase_prob < mts->reference_prob)
+		mts->sample_power += TPC_MIN_POWER_INCREMENT;
+
+	/* adjust reference power level */
+	valid_ref_prob = MINSTREL_FRAC(100 - TPC_DECREASE_PROB_THRESH, 100);
+	invalid_ref_prob = MINSTREL_FRAC(100 - TPC_INCREASE_PROB_THRESH, 100);
+
+	if ((mts->reference_prob > valid_ref_prob ||
+	     mts->sample_prob > valid_ref_prob) &&
+	    (mts->reference_power >= mts->sample_power +
+					TPC_SAMPLE_POWER_SPAN +
+					TPC_MIN_POWER_DECREMENT * 2))
+		mts->reference_power -= TPC_MIN_POWER_DECREMENT;
+	else if (mts->reference_prob < invalid_ref_prob)
+		mts->reference_power += TPC_MIN_POWER_INCREMENT;
+}
+
+/*
+ * Find common power level out of all potential data rates for ACK packets.
+ */
+static void
+blues_find_common_ack_power (struct minstrel_sta_info *priv_sta,
+			     s8 *global_ack_power, s8 *max_power_level)
+{
+	bool valid_ack_power_found = false;
+	s8 sample_power;
+	int i;
+
+	for (i = priv_sta->n_rates; i > 0; i--) {
+		switch (priv_sta->r[i].bitrate) {
+		case 48: case 24: case 12: case 22: case 11: case 4: case 2:
+			sample_power = priv_sta->r[i].tpc_stats.sample_power;
+			if (sample_power + TPC_SAMPLE_POWER_SPAN >
+			    *global_ack_power) {
+				*global_ack_power = sample_power +
+							TPC_SAMPLE_POWER_SPAN;
+				valid_ack_power_found = true;
+				// printk(KERN_ERR "per STA ACK-POWER at %i.%i
+				// MBit = %i dBm\n", priv_sta->r[i]->bitrate / 2,
+				// priv_sta->r[i]->bitrate % 2 ? 5 : 0, global_ack_power);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	if (!valid_ack_power_found)
+		*global_ack_power = *max_power_level;
+}
+
+/*
+ * Adjust global ACK power level to the maximum common data power level among
+ * all active STAs. Compare power levels at whole set of potential ack rates.
+ *
+ * TODO: check carefully with multicast power !!! routing like OLSR uses it
+ */
+static void
+blues_adjust_ack_power(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
+{
+	struct ieee80211_hw *hw = mp->hw;
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct minstrel_sta_info *priv_sta;
+	struct sta_info *sta;
+	s8 max_power_level = hw->conf.power_level;
+	s8 min_power_level = hw->min_txpower;
+	s8 global_ack_power = min_power_level;
+
+	/* find common ACK power between all STAs */
+	rcu_read_lock();
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		priv_sta = sta->rate_ctrl_priv;
+		// printk(KERN_ERR "new STA found -> %p\n", sta->rate_ctrl_priv);
+		blues_find_common_ack_power(priv_sta,
+					    &global_ack_power,
+					    &max_power_level);
+	}
+	rcu_read_unlock();
+
+	/* validate ACK power value */
+	if (global_ack_power < min_power_level)
+		global_ack_power = min_power_level;
+	else if (global_ack_power > max_power_level)
+		global_ack_power = max_power_level;
+
+	blues_set_ack_power(hw, global_ack_power);
+	// printk(KERN_ERR "Searching STA neighbor list results in global
+	// ack_power = %i\n", i, hw->conf.ack_power);
+
+	/* annotate ack power in minstrel_sta_info to update statistics */
+	mi->tpc_ack_txpower = hw->conf.ack_txpower;
+}
+
+/* Update all TPC statistics if enough samples got collected */
+void
+blues_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
+{
+	struct ieee80211_hw *hw = mp->hw;
+	struct minstrel_rate *mr;
+	struct blues_tpc_stats *mts;
+	s8 max_power_level = hw->conf.power_level;
+	int i;
+
+	/* Start from highest rate to lowest in order */
+	// FIXME: this order just works for 802.11a ! not for 802.11b/g
+	for (i = (mi->n_rates - 1); i >= 0; i--) {
+		mr = &(mi->r[i]);
+		mts = &(mi->r[i].tpc_stats);
+
+		/* if enough samples collected update success probabilities */
+		/* TODO: TPC_UPDATE_THRESH_SAMPLE correct? */
+		if ((mts->reference_attempts > TPC_UPDATE_THRESH_SAMPLE) &&
+		    (mts->sample_attempts > TPC_UPDATE_THRESH_SAMPLE)) {
+			blues_calc_ewma(mr, EWMA_REF_POWER | EWMA_SAMPLE_POWER);
+			mr->tpc_stats.stats_outdated = 100;
+
+			/* check if emergency */
+			// FIXME: is this test right here ?
+			if (mts->reference_prob <
+			    MINSTREL_FRAC(TPC_EMERG_THRESH, 100)) {
+					blues_reset_power(mp, mr);
+					blues_reset_stats(mr);
+					continue;
+			}
+
+			/* trigger power level adjustments */
+			blues_adjust_power_levels(mr);
+		}
+
+		/* if stats are unsampled, adjust them according to others */
+		if (mr->tpc_stats.stats_outdated == 0) {
+			/* Unsampled higher rates are reset */
+			if ((i > mi->max_tp_rate[0]) &&
+			    (i > mi->max_tp_rate[1]) &&
+			    (i > mi->max_tp_rate[2])) {
+				blues_reset_power(mp, mr);
+				blues_reset_stats(mr);
+			}
+
+			/*
+			 * Unsampled lower rates are equal to next higher one
+			 * (assumed linear decreasing robustness of rates)
+			 * (FIXME: create sorted rate list for 802.11g)
+			 */
+			if (i < mi->max_tp_rate[0] && i < mi->max_tp_rate[1]) {
+				mts->reference_power =
+					mi->r[i + 1].tpc_stats.reference_power;
+				mts->sample_power =
+					mi->r[i + 1].tpc_stats.sample_power;
+				blues_reset_stats(mr);
+			}
+		}
+
+		/* validate power settings */
+		blues_validate_power_level(mp, mr);
+
+		//printk(KERN_ERR "tpc; rate= %i.%i tpc_sample_power= %i
+		// tpc_sample_attempts= %i\n", mr->bitrate / 2,
+		// mr->bitrate % 2 ? 5 : 0, mr->tpc_sample_power,
+		//mr->tpc_sample_attempts);
+	}
+
+	/*
+	 * Test utility & adjust power of ACK packets
+	 * utility dependend
+	 */
+	if (mp->has_ack_tpc) {
+		if (mp->dbg_thr_weight >= 100)
+			blues_set_ack_power(hw, max_power_level);
+		else
+			blues_adjust_ack_power(mp, mi);
+	}
+}
+
+struct blues_tpc_stats *
+blues_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		   struct ieee80211_tx_rate *rate)
+{
+	int group, idx;
+
+	if (rate->flags & IEEE80211_TX_RC_MCS) {
+	            group = blues_ht_get_group_idx(rate);
+		            idx = rate->idx % 8;
+	} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
+	            group = blues_vht_get_group_idx(rate);
+		            idx = ieee80211_rate_get_vht_mcs(rate);
+	} else {
+		group = MINSTREL_CCK_GROUP;
+
+		for (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++)
+			if (rate->idx == mp->cck_rates[idx])
+				break;
+
+		/* short preamble */
+		if (!(mi->supported[group] & BIT(idx)))
+			idx += 4;
+	}
+	return &mi->groups[group].tpc_stats[idx];
+}
+
+void
+blues_count_tx_attempts(struct minstrel_rate *mr,
+			int count, s8 power)
+{
+	if (power == mr->tpc_stats.reference_power) {
+		mr->tpc_stats.reference_attempts += count;
+		mr->tpc_stats.ref_att_hist += count;
+	}
+
+	if (power == mr->tpc_stats.sample_power +
+	    TPC_SAMPLE_POWER_SPAN)
+		mr->tpc_stats.data_attempts += count;
+
+	if (power == mr->tpc_stats.sample_power) {
+		mr->tpc_stats.sample_attempts += count;
+		mr->tpc_stats.sample_att_hist += count;
+	}
+}
+
+void
+blues_count_tx_success(struct minstrel_rate *mr,
+		       int count, s8 power)
+{
+	if (power == mr->tpc_stats.reference_power) {
+		mr->tpc_stats.reference_success += count;
+		mr->tpc_stats.ref_succ_hist += count;
+	}
+
+	if (power == mr->tpc_stats.sample_power +
+	    TPC_SAMPLE_POWER_SPAN)
+		mr->tpc_stats.data_success += count;
+
+	if (power == mr->tpc_stats.sample_power) {
+		mr->tpc_stats.sample_success += count;
+		mr->tpc_stats.sample_succ_hist += count;
+	}
+	//FIXME: should we really account for it this way?
+	if (power < mr->tpc_stats.sample_power) {
+		mr->tpc_stats.sample_attempts += count;
+		mr->tpc_stats.sample_success += count;
+	}
+	/*
+	* TODO: what about higher/lower power-levels ->
+	* only count if not/true successful ?
+	*/
+}
+
+static inline unsigned int
+blues_get_curent_txpower(struct minstrel_sta_info *mi, int i)
+{
+	u32 cur_txpower;
+
+	cur_txpower = convert_dBm_to_uW(mi->r[mi->max_tp_rate[i]].tpc_stats.sample_power +
+				TPC_SAMPLE_POWER_SPAN);
+	return cur_txpower;
+}
+
+static int
+blues_calc_utility(int rel_thr, int rel_interference)
+{
+	u8 thr_weight;
+	int u;
+
+	/* Use default weighting factor as throughput over interference.
+	 * A factor of 100 represents an egoistic preference, that focuses
+	 * on maximizing throughput and not interference/txpower savings. */
+	thr_weight = BLUES_DEFAULT_THR_WEIGHT;
+
+#ifdef CONFIG_MAC80211_DEBUGFS
+	/* use custom throughput weighting factor if specified via debugfs */
+	if ((mp->dbg_thr_weight <= 100) && (mp->dbg_thr_weight >= 10))
+		thr_weight = mp->dbg_thr_weight;
+#endif
+
+	u = rel_thr * thr_weight - rel_interference * 10;
+
+	return u;
+}
+
+int
+blues_get_next_sample_rate(struct minstrel_sta_info *mi)
+{
+	unsigned int sample_rate;
+
+	/* for TPC sampling alternate between all max_tp_rates */
+	if (mi->tpc_measuring_point == 0) {
+		sample_rate = mi->max_tp_rate[0];
+		mi->tpc_measuring_point = 1;
+	} else if (mi->tpc_measuring_point == 1) {
+		sample_rate = mi->max_tp_rate[1];
+		mi->tpc_measuring_point = 2;
+	} else {
+		if (mi->r[mi->max_tp_rate[2]].perfect_tx_time >
+		    mi->r[mi->max_tp_rate[0]].perfect_tx_time)
+			sample_rate = mi->max_tp_rate[2];
+		else
+			sample_rate = mi->max_prob_rate;
+
+		mi->tpc_measuring_point = 1;
+	}
+	return sample_rate;
+}
+
+int
+blues_ht_get_next_sample_rate(struct minstrel_ht_sta *mi)
+{
+	unsigned int sample_rate;
+	int tmp_idx, tmp_group, dur_rate0, dur_rate2;
+
+	/* for TPC sampling alternate between all max_tp_rates */
+	if (mi->tpc_measuring_point == 0) {
+		sample_rate = mi->max_tp_rate[0];
+		mi->tpc_measuring_point = 1;
+	} else if (mi->tpc_measuring_point == 1) {
+		sample_rate = mi->max_tp_rate[1];
+		mi->tpc_measuring_point = 2;
+	} else {
+		tmp_idx = mi->max_tp_rate[0] % MCS_GROUP_RATES;
+		tmp_group = mi->max_tp_rate[0] / MCS_GROUP_RATES;
+		dur_rate0 = minstrel_mcs_groups[tmp_group].duration[tmp_idx];
+		tmp_idx = mi->max_tp_rate[2] % MCS_GROUP_RATES;
+		tmp_group = mi->max_tp_rate[2] / MCS_GROUP_RATES;
+		dur_rate2 = minstrel_mcs_groups[tmp_group].duration[tmp_idx];
+
+		if (dur_rate2 > dur_rate0)
+			sample_rate = mi->max_tp_rate[2];
+		else
+			sample_rate = mi->max_prob_rate;
+
+		mi->tpc_measuring_point = 1;
+	}
+	return sample_rate;
+}
+
+/* check whether rate sampling is required */
+bool
+blues_requires_sampling(struct minstrel_sta_info *mi,
+			struct minstrel_priv *mp,
+			bool mrr_capable)
+{
+	int blues_sampling_interval;
+
+	/* Check multi-rate-retry capabilities & adjust sampling interval */
+	if (mrr_capable)
+		blues_sampling_interval = RATE_SAMPLING_INT * 2;
+	else
+		blues_sampling_interval = RATE_SAMPLING_INT * 4;
+
+	if (time_after(jiffies, mi->last_tpc_update +
+	    (blues_sampling_interval * HZ) / 1000)) {
+		mi->last_tpc_update = jiffies;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+/* check whether rate sampling is required */
+bool
+blues_ht_requires_sampling(struct minstrel_ht_sta *mi,
+			   struct minstrel_priv *mp,
+			   bool mrr_capable)
+{
+	int blues_sampling_interval;
+
+	/* Check multi-rate-retry capabilities & adjust sampling interval */
+	if (mrr_capable)
+		blues_sampling_interval = RATE_SAMPLING_INT * 2;
+	else
+		blues_sampling_interval = RATE_SAMPLING_INT * 4;
+
+	if (time_after(jiffies, mi->last_tpc_update +
+	    (blues_sampling_interval * HZ) / 1000)) {
+		mi->last_tpc_update = jiffies;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+/*
+ * Minstrel-Blues core function:
+ * Calculate joint utility function of those (rate, txpower) pairs, where
+ * Minstrel determines the sorted best throughput rate set.
+ * For algorithmic details, please lookup the details at:
+ * http://opus4.kobv.de/opus4-tuberlin/frontdoor/index/index/docId/3939
+ */
+void minstrel_blues_update_rate_power_table(struct minstrel_priv *mp,
+					    struct minstrel_sta_info *mi)
+{
+	struct blues_utility set[MAX_THR_RATES];
+	int i;
+	u8 max_utility_index = 0;
+
+	/* Calculate joint utility */
+	//TODO: check if manual txpower[mrr] was set via debugfs
+	for(i = 0; i < MAX_THR_RATES; i++) {
+		struct minstrel_rate *mr = &mi->r[i];
+		struct minstrel_rate_stats *mrs = &mi->r[i].rc_stats;
+
+		set[i].cur_thr = minstrel_get_tp_avg(mr, mrs->prob_ewma);
+		set[i].cur_pwr = blues_get_curent_txpower(mi, i);
+
+		if (set[i].cur_thr) {
+			set[i].pwr_thr_ratio = MINSTREL_FRAC(set[i].cur_pwr,
+							     set[i].cur_thr);
+			set[i].rel_thr = MINSTREL_FRAC(set[i].cur_thr,
+						       set[0].cur_thr);
+			set[i].rel_intrf = MINSTREL_FRAC(set[i].pwr_thr_ratio,
+							set[0].pwr_thr_ratio);
+		} else {
+			set[i].rel_thr = 0;
+			set[i].rel_intrf = 0;
+		}
+
+		set[i].utility = blues_calc_utility(set[i].rel_thr,
+						    set[i].rel_intrf);
+
+		if ((i > 0 ) && (set[i].utility > set[i-1].utility))
+			max_utility_index = i;
+	}
+}
--- /dev/null
+++ b/net/mac80211/tpc80211_blues.h
@@ -0,0 +1,101 @@
+/*
+ * Transmit Power Control (TPC) algorithm "MINSTREL-BLUES".
+ * ________________________________________________________________________
+ * A decentralized joint power and rate controller and hepcat that plays as
+ * loud as thourghput vs. interference is weighted. Power and rate per link
+ * (per packet) is under its control to replace static WiFi shouting with
+ * dynamic use and interplay. The big goal is to increase overall network
+ * performance by increasing spatial reuse, more active links in parallel.
+ *
+ * Copyright (C) 2016  Thomas Huehn <thomas@net.t-labs.tu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef __TPC80211_BLUES_H
+#define __TPC80211_BLUES_H
+
+#include <net/mac80211.h>
+#include "rate.h"
+#include "common.h"
+#include "rc80211_minstrel.h"
+#include "rc80211_minstrel_ht.h"
+
+#define TPC_SAMPLE_POWER_SPAN 2		/* min span of sample below ref.power */
+#define TPC_MIN_POWER_DECREMENT 1	/* step width of tx-power decrease */
+#define TPC_MIN_POWER_INCREMENT 2	/* step width of tx-power increase */
+#define TPC_PROBING_RATIO 10		/* packet ratio [%] of TPC sampling */
+#define TPC_UPDATE_THRESH_SAMPLE 35	/* sample packet thr. to update TPC */
+#define TPC_UPDATE_THRESH_DATA 12	/* data packet thr. to update TPC */
+#define TPC_UPDATE_INTERVAL 200		/* TPC update interval [ms] */
+#define TPC_DECREASE_PROB_THRESH 12	/* thresh.[%] -> 1 power level down */
+#define TPC_INCREASE_PROB_THRESH 22	/* thresh.[%] -> 1 power level up */
+#define TPC_EMERG_THRESH 30		/* emerg. thresh. [%] -> max power */
+#define TPC_INIT_REF_PROB 90		/* initial ewma ref prob. [%] */
+#define TPC_INIT_DATA_PROB 85		/* initial ewma data prob. [%] */
+#define TPC_INIT_SAMPLE_PROB 80		/* initial ewma sample prob. [%] */
+#define BLUES_DEFAULT_THR_WEIGHT 100	/* weighting factor in utility calc */
+
+enum blues_ewma_update_flags {
+	EWMA_REF_POWER		= BIT(0),
+	EWMA_SAMPLE_POWER	= BIT(1),
+	EWMA_DATA_POWER		= BIT(2),
+};
+
+struct blues_utility {
+	int cur_thr;
+	int cur_pwr;
+	int pwr_thr_ratio;
+	int rel_thr;
+	int rel_intrf;
+	int utility;
+	int max_utility_index;
+};
+
+int blues_set_ack_power(struct ieee80211_hw *hw, s8 val);
+
+void blues_update_stats(struct minstrel_priv *mp,
+			struct minstrel_sta_info *mi);
+
+void blues_count_tx_attempts(struct minstrel_rate *mr,
+			      int count,
+			      s8 power);
+
+void blues_reset_stats(struct minstrel_rate *mr);
+
+void blues_reset_power(struct minstrel_priv *mp,
+		       struct minstrel_rate *mr);
+
+void blues_ht_reset_power(struct minstrel_ht_sta *mi,
+			  struct ieee80211_hw *hw,
+			  int group, int rate);
+
+void blues_ht_tpc_init(struct minstrel_priv *mp,
+		       struct minstrel_ht_sta_priv *msp);
+
+void blues_count_tx_success(struct minstrel_rate *mr,
+			     int count,
+			     s8 power);
+
+void minstrel_blues_update_rate_power_table(struct minstrel_priv *mp,
+					    struct minstrel_sta_info *mi);
+
+bool blues_requires_sampling(struct minstrel_sta_info *mi,
+			     struct minstrel_priv *mp,
+			     bool mrr_capable);
+
+bool blues_ht_requires_sampling(struct minstrel_ht_sta *mi,
+				struct minstrel_priv *mp,
+				bool mrr_capable);
+
+int blues_get_next_sample_rate(struct minstrel_sta_info *mi);
+
+int blues_ht_get_next_sample_rate(struct minstrel_ht_sta *mi);
+
+struct blues_tpc_stats *blues_ht_get_stats(struct minstrel_priv *mp,
+					   struct minstrel_ht_sta *mi,
+					   struct ieee80211_tx_rate *rate);
+#endif
--- a/net/mac80211/rc80211_minstrel.c
+++ b/net/mac80211/rc80211_minstrel.c
@@ -710,6 +710,11 @@ minstrel_alloc(struct ieee80211_hw *hw,
 
 	mp->hw = hw;
 
+	/* check TPC capabilities of current WiFi hardware driver */
+	mp->has_tpc_per_packet = ieee80211_hw_check(hw, SUPPORTS_TPC_PER_PACKET);
+	mp->has_tpc_per_mrr = ieee80211_hw_check(hw, SUPPORTS_TPC_PER_MRR);
+	mp->has_ack_tpc = ieee80211_hw_check(hw, SUPPORTS_TPC_FOR_ACK_PACKETS);
+
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	mp->fixed_rate_idx = (u32) -1;
 	mp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",
--- a/net/mac80211/rc80211_minstrel.h
+++ b/net/mac80211/rc80211_minstrel.h
@@ -9,6 +9,8 @@
 #ifndef __RC_MINSTREL_H
 #define __RC_MINSTREL_H
 
+#include "common.h"
+
 #define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
 #define EWMV_LEVEL	121
 #define EWMA_DIV	128
@@ -56,28 +58,6 @@ minstrel_ewmv(int old_ewmv, int cur_prob
 	return weight * (old_ewmv + MINSTREL_TRUNC(diff * incr)) / EWMA_DIV;
 }
 
-struct minstrel_rate_stats {
-	/* current / last sampling period attempts/success counters */
-	u16 attempts, last_attempts;
-	u16 success, last_success;
-
-	/* total attempts/success counters */
-	u32 att_hist, succ_hist;
-
-	/* statistis of packet delivery probability
-	 *  prob_ewma - exponential weighted moving average of prob
-	 *  prob_ewmsd - exp. weighted moving standard deviation of prob */
-	u16 prob_ewma;
-	u16 prob_ewmv;
-
-	/* maximum retry counts */
-	u8 retry_count;
-	u8 retry_count_rtscts;
-
-	u8 sample_skipped;
-	bool retry_updated;
-};
-
 struct minstrel_rate {
 	int bitrate;
 
@@ -91,6 +71,7 @@ struct minstrel_rate {
 	int sample_limit;
 
 	struct minstrel_rate_stats rc_stats;
+	struct blues_tpc_stats tpc_stats;
 };
 
 struct minstrel_sta_info {
@@ -98,6 +79,7 @@ struct minstrel_sta_info {
 
 	unsigned long last_stats_update;
 	unsigned long last_rate_update;
+	unsigned long last_tpc_update;
 	unsigned int sp_ack_dur;
 	unsigned int rate_avg;
 
@@ -118,6 +100,10 @@ struct minstrel_sta_info {
 	/* sampling table */
 	u8 *sample_table;
 
+	u8 tpc_sample_probe_counter;
+	u8 tpc_measuring_point;
+	s8 tpc_ack_txpower;
+
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	struct dentry *dbg_stats;
 	struct dentry *dbg_stats_csv;
@@ -136,6 +122,11 @@ struct minstrel_priv {
 	unsigned int segment_size;
 	bool has_mrr;
 
+	/* hardware capabilities of tx power adjustments */
+	bool has_tpc_per_packet;
+	bool has_tpc_per_mrr;
+	bool has_ack_tpc;
+
 	u8 cck_rates[4];
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -147,6 +138,17 @@ struct minstrel_priv {
 	 */
 	u32 fixed_rate_idx;
 	struct dentry *dbg_fixed_rate;
+	/*
+	 * enable custom throughput weighting factor for the joint utility
+	 * decision of power-rate preferences
+	 * - high thr_factor means accepting lower throughput degradation per
+	 *   saved txpower (more egoistic)
+	 * - thr_factor of 1 leads to utility calculation based on throughput
+	 *   and jamming equaly (more altruistic)
+	 * - reasonable thr_factors are between 10 and 2 to value the throughput
+	 *   more than the jamming (default thr_weigt = 2)
+	 */
+	s8 dbg_thr_weight;
 #endif
 };
 
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -9,36 +9,7 @@
 #ifndef __RC_MINSTREL_HT_H
 #define __RC_MINSTREL_HT_H
 
-/*
- * The number of streams can be changed to 2 to reduce code
- * size and memory footprint.
- */
-#define MINSTREL_MAX_STREAMS		3
-#define MINSTREL_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
-#define MINSTREL_VHT_STREAM_GROUPS	6 /* BW(=3) * SGI(=2) */
-#else
-#define MINSTREL_VHT_STREAM_GROUPS	0
-#endif
-
-#define MINSTREL_HT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
-				 MINSTREL_HT_STREAM_GROUPS)
-#define MINSTREL_VHT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
-				 MINSTREL_VHT_STREAM_GROUPS)
-#define MINSTREL_CCK_GROUPS_NB	1
-#define MINSTREL_GROUPS_NB	(MINSTREL_HT_GROUPS_NB +	\
-				 MINSTREL_VHT_GROUPS_NB +	\
-				 MINSTREL_CCK_GROUPS_NB)
-
-#define MINSTREL_HT_GROUP_0	0
-#define MINSTREL_CCK_GROUP	(MINSTREL_HT_GROUP_0 + MINSTREL_HT_GROUPS_NB)
-#define MINSTREL_VHT_GROUP_0	(MINSTREL_CCK_GROUP + 1)
-
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
-#define MCS_GROUP_RATES		10
-#else
-#define MCS_GROUP_RATES		8
-#endif
+#include "common.h"
 
 struct mcs_group {
 	u32 flags;
@@ -54,6 +25,9 @@ struct minstrel_mcs_group_data {
 
 	/* MCS rate statistics */
 	struct minstrel_rate_stats rc_stats[MCS_GROUP_RATES];
+
+	/* MCS tpc statistics */
+	struct blues_tpc_stats tpc_stats[MCS_GROUP_RATES];
 };
 
 struct minstrel_ht_sta {
@@ -76,6 +50,9 @@ struct minstrel_ht_sta {
 	/* time of last rate sampling update */
 	unsigned long last_rate_update;
 
+	/* time of last tpc sampling update */
+	unsigned long last_tpc_update;
+
 	/* min # of packets between sample attempts */
 	u8 cur_rc_intersample_spacing;
 
@@ -101,6 +78,9 @@ struct minstrel_ht_sta {
 
 	/* MCS rate group info and statistics */
 	struct minstrel_mcs_group_data groups[MINSTREL_GROUPS_NB];
+
+	u8 tpc_measuring_point;
+	s8 tpc_ack_txpower;
 };
 
 struct minstrel_ht_sta_priv {
--- a/net/mac80211/rc80211_minstrel_debugfs.c
+++ b/net/mac80211/rc80211_minstrel_debugfs.c
@@ -53,6 +53,7 @@
 #include <linux/export.h>
 #include <net/mac80211.h>
 #include "rc80211_minstrel.h"
+#include "tpc80211_blues.h"
 
 ssize_t
 minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
@@ -75,25 +76,25 @@ minstrel_stats_open(struct inode *inode,
 {
 	struct minstrel_sta_info *mi = inode->i_private;
 	struct minstrel_debugfs_info *ms;
-	unsigned int i, tp_max, tp_avg, eprob;
+	unsigned int i, tp_max, tp_avg, eprob, ref_prob, data_prob, sample_prob;
 	char *p;
 	struct timeval tv;
 
-	ms = kmalloc(2048, GFP_KERNEL);
+	ms = kmalloc(4096, GFP_KERNEL);
 	if (!ms)
 		return -ENOMEM;
 
 	file->private_data = ms;
 	p = ms->buf;
 	p += sprintf(p, "\n");
-	p += sprintf(p,
-		     "best   __________rate_________    ________statistics________    ____last_____    ______sum-of________\n");
-	p += sprintf(p,
-		     "rate  [name idx airtime max_tp]  [avg(tp) avg(prob) sd(prob)]  [retry|suc|att]  [#success | #attempts]\n");
+	p += sprintf(p,"best   __________rate_________    ______rc-statistics_______    ____last_____    ______sum-of________    _________________________tpc-statistics__________________________\n");
+	p += sprintf(p,"rate  [name idx airtime max_tp]  [avg(tp) avg(prob) sd(prob)]  [retry|suc|att]  [#success | #attempts]  [     sample-power    |   reference-power   |      data-power     ]\n");
+	p += sprintf(p,"													[  suc|att   prob dBm |  suc|att   prob dBm |  suc|att   prob dBm ]\n");
 
 	for (i = 0; i < mi->n_rates; i++) {
 		struct minstrel_rate *mr = &mi->r[i];
 		struct minstrel_rate_stats *mrs = &mi->r[i].rc_stats;
+		struct blues_tpc_stats *mts = &mi->r[i].tpc_stats;
 		unsigned int prob_ewmsd;
 
 		*(p++) = (i == mi->max_tp_rate[0]) ? 'A' : ' ';
@@ -111,10 +112,14 @@ minstrel_stats_open(struct inode *inode,
 		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
 		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+		ref_prob = MINSTREL_TRUNC(mts->reference_prob * 1000);
+		data_prob = MINSTREL_TRUNC(mts->data_prob * 1000);
+		sample_prob = MINSTREL_TRUNC(mts->sample_prob * 1000);
 
 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u    %3u.%1u"
-				"     %3u   %3u %-3u   "
-				"%9u   %-9u\n",
+				"     %3u   %3u %-3u   %9u   %-9u    "
+				"%5u %-5u%3u.%1u %3u  %5u %-5u%3u.%1u %3u"
+				"  %5u %-5u%3u.%1u %3u\n",
 				tp_max / 10, tp_max % 10,
 				tp_avg / 10, tp_avg % 10,
 				eprob / 10, eprob % 10,
@@ -123,16 +128,30 @@ minstrel_stats_open(struct inode *inode,
 				mrs->last_success,
 				mrs->last_attempts,
 				mrs->succ_hist,
-				mrs->att_hist);
+				mrs->att_hist,
+				mts->sample_succ_hist,
+				mts->sample_att_hist,
+				sample_prob / 10, sample_prob % 10,
+				mts->sample_power,
+				mts->ref_succ_hist,
+				mts->ref_att_hist,
+				ref_prob / 10, ref_prob % 10,
+				mts->reference_power,
+				mts->data_success,
+				mts->data_attempts,
+				data_prob / 10, data_prob % 10,
+				mts->sample_power + TPC_SAMPLE_POWER_SPAN);
 	}
 	do_gettimeofday(&tv);
 	p += sprintf(p, "\nTotal packet count::    ideal %d      "
-			"lookaround %d,    timestamp: %ld.%.6ld\n\n",
+			"lookaround %d \nTimestamp: %ld.%.6ld\n"
+			"tx-power of ack packets [dBm]: %2u\n\n",
 			mi->total_packets - mi->sample_packets,
-			mi->sample_packets, tv.tv_sec, tv.tv_usec);
+			mi->sample_packets, tv.tv_sec, tv.tv_usec,
+			mi->tpc_ack_txpower);
 	ms->len = p - ms->buf;
 
-	WARN_ON(ms->len + sizeof(*ms) > 2048);
+	WARN_ON(ms->len + sizeof(*ms) > 4096);
 
 	return 0;
 }
@@ -150,11 +169,11 @@ minstrel_stats_csv_open(struct inode *in
 {
 	struct minstrel_sta_info *mi = inode->i_private;
 	struct minstrel_debugfs_info *ms;
-	unsigned int i, tp_max, tp_avg, eprob;
+	unsigned int i, tp_max, tp_avg, eprob, ref_prob, data_prob, sample_prob;
 	char *p;
 	struct timeval tv;
 
-	ms = kmalloc(2048, GFP_KERNEL);
+	ms = kmalloc(4096, GFP_KERNEL);
 	if (!ms)
 		return -ENOMEM;
 
@@ -165,6 +184,7 @@ minstrel_stats_csv_open(struct inode *in
 	for (i = 0; i < mi->n_rates; i++) {
 		struct minstrel_rate *mr = &mi->r[i];
 		struct minstrel_rate_stats *mrs = &mi->r[i].rc_stats;
+		struct blues_tpc_stats *mts = &mi->r[i].tpc_stats;
 		unsigned int prob_ewmsd;
 
 		p += sprintf(p, "%ld.%.6ld,", tv.tv_sec, tv.tv_usec);
@@ -183,9 +203,13 @@ minstrel_stats_csv_open(struct inode *in
 		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
 		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
-
-		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,%u,"
-				"%u,%u,%d,%d\n",
+		ref_prob = MINSTREL_TRUNC(mts->reference_prob * 1000);
+		data_prob = MINSTREL_TRUNC(mts->data_prob * 1000);
+		sample_prob = MINSTREL_TRUNC(mts->sample_prob * 1000);
+
+		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,"
+				"%u,%u,%u,%d,%d,%u,%u,%u,%u,%u,"
+				"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u\n",
 				tp_max / 10, tp_max % 10,
 				tp_avg / 10, tp_avg % 10,
 				eprob / 10, eprob % 10,
@@ -196,12 +220,24 @@ minstrel_stats_csv_open(struct inode *in
 				mrs->succ_hist,
 				mrs->att_hist,
 				mi->total_packets - mi->sample_packets,
-				mi->sample_packets);
-
+				mi->sample_packets,
+				mts->sample_succ_hist,
+				mts->sample_att_hist,
+				sample_prob / 10, sample_prob % 10,
+				mts->sample_power,
+				mts->ref_succ_hist,
+				mts->ref_att_hist,
+				ref_prob / 10, ref_prob % 10,
+				mts->reference_power,
+				mts->data_success,
+				mts->data_attempts,
+				data_prob / 10, data_prob % 10,
+				mts->sample_power + TPC_SAMPLE_POWER_SPAN,
+				mi->tpc_ack_txpower);
 	}
 	ms->len = p - ms->buf;
 
-	WARN_ON(ms->len + sizeof(*ms) > 2048);
+	WARN_ON(ms->len + sizeof(*ms) > 4096);
 
 	return 0;
 }
--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
@@ -14,12 +14,14 @@
 #include <net/mac80211.h>
 #include "rc80211_minstrel.h"
 #include "rc80211_minstrel_ht.h"
+#include "tpc80211_blues.h"
 
 static char *
 minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
 {
 	const struct mcs_group *mg;
 	unsigned int j, tp_max, tp_avg, eprob, tx_time;
+	unsigned int ref_prob, data_prob, sample_prob;
 	char htmode = '2';
 	char gimode = 'L';
 	u32 gflags;
@@ -39,6 +41,7 @@ minstrel_ht_stats_dump(struct minstrel_h
 
 	for (j = 0; j < MCS_GROUP_RATES; j++) {
 		struct minstrel_rate_stats *mrs = &mi->groups[i].rc_stats[j];
+		struct blues_tpc_stats *mts = &mi->groups[i].tpc_stats[j];
 		static const int bitrates[4] = { 10, 20, 55, 110 };
 		int idx = i * MCS_GROUP_RATES + j;
 		unsigned int prob_ewmsd;
@@ -86,10 +89,15 @@ minstrel_ht_stats_dump(struct minstrel_h
 		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
 		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+		ref_prob = MINSTREL_TRUNC(mts->reference_prob * 1000);
+		data_prob = MINSTREL_TRUNC(mts->data_prob * 1000);
+		sample_prob = MINSTREL_TRUNC(mts->sample_prob * 1000);
 
 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u    %3u.%1u"
 				"     %3u   %3u %-3u   "
-				"%9u   %-9u\n",
+				"%9u   %-9u    "
+				"%5u %-5u%3u.%1u %3u  %5u %-5u%3u.%1u %3u"
+				"  %5u %-5u%3u.%1u %3u\n",
 				tp_max / 10, tp_max % 10,
 				tp_avg / 10, tp_avg % 10,
 				eprob / 10, eprob % 10,
@@ -98,7 +106,19 @@ minstrel_ht_stats_dump(struct minstrel_h
 				mrs->last_success,
 				mrs->last_attempts,
 				mrs->succ_hist,
-				mrs->att_hist);
+				mrs->att_hist,
+				mts->sample_succ_hist,
+				mts->sample_att_hist,
+				sample_prob / 10, sample_prob % 10,
+				mts->sample_power,
+				mts->ref_succ_hist,
+				mts->ref_att_hist,
+				ref_prob / 10, ref_prob % 10,
+				mts->reference_power,
+				mts->data_success,
+				mts->data_attempts,
+				data_prob / 10, data_prob % 10,
+				mts->sample_power + TPC_SAMPLE_POWER_SPAN);
 	}
 
 	return p;
@@ -130,10 +150,9 @@ minstrel_ht_stats_open(struct inode *ino
 	p = ms->buf;
 
 	p += sprintf(p, "\n");
-	p += sprintf(p,
-		     "              best   ____________rate__________    ________statistics________    _____last____    ______sum-of________\n");
-	p += sprintf(p,
-		     "mode guard #  rate  [name   idx airtime  max_tp]  [avg(tp) avg(prob) sd(prob)]  [retry|suc|att]  [#success | #attempts]\n");
+	p += sprintf(p,"              best   ____________rate__________    ________statistics________    _____last____    ______sum-of________    _________________________tpc-statistics__________________________\n");
+	p += sprintf(p,"mode guard #  rate  [name   idx airtime  max_tp]  [avg(tp) avg(prob) sd(prob)]  [retry|suc|att]  [#success | #attempts]  [     sample-power    |   reference-power   |      data-power     ]\n");
+	p += sprintf(p,"															 [  suc|att   prob dBm |  suc|att   prob dBm |  suc|att   prob dBm ]\n");
 
 	p = minstrel_ht_stats_dump(mi, MINSTREL_CCK_GROUP, p);
 	for (i = 0; i < MINSTREL_CCK_GROUP; i++)
@@ -150,6 +169,7 @@ minstrel_ht_stats_open(struct inode *ino
 		MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
 	do_gettimeofday(&tv);
 	p += sprintf(p, "Timestamp: %ld.%.6ld\n", tv.tv_sec, tv.tv_usec);
+	p += sprintf(p, "tx-power of ack packets [dBm]: %2u\n\n", mi->tpc_ack_txpower);
 	ms->len = p - ms->buf;
 	WARN_ON(ms->len + sizeof(*ms) > 32768);
 
@@ -170,6 +190,7 @@ minstrel_ht_stats_csv_dump(struct minstr
 {
 	const struct mcs_group *mg;
 	unsigned int j, tp_max, tp_avg, eprob, tx_time;
+	unsigned int ref_prob, data_prob, sample_prob;
 	char htmode = '2';
 	char gimode = 'L';
 	u32 gflags;
@@ -189,6 +210,7 @@ minstrel_ht_stats_csv_dump(struct minstr
 
 	for (j = 0; j < MCS_GROUP_RATES; j++) {
 		struct minstrel_rate_stats *mrs = &mi->groups[i].rc_stats[j];
+		struct blues_tpc_stats *mts = &mi->groups[i].tpc_stats[j];
 		static const int bitrates[4] = { 10, 20, 55, 110 };
 		int idx = i * MCS_GROUP_RATES + j;
 		unsigned int prob_ewmsd;
@@ -235,9 +257,12 @@ minstrel_ht_stats_csv_dump(struct minstr
 		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
 		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+		ref_prob = MINSTREL_TRUNC(mts->reference_prob * 1000);
+		data_prob = MINSTREL_TRUNC(mts->data_prob * 1000);
+		sample_prob = MINSTREL_TRUNC(mts->sample_prob * 1000);
 
-		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,"
-				"%u,%u,%u,",
+		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,%u,%u,%u,"
+				"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,",
 				tp_max / 10, tp_max % 10,
 				tp_avg / 10, tp_avg % 10,
 				eprob / 10, eprob % 10,
@@ -246,7 +271,18 @@ minstrel_ht_stats_csv_dump(struct minstr
 				mrs->last_success,
 				mrs->last_attempts,
 				mrs->succ_hist,
-				mrs->att_hist);
+				mrs->att_hist,
+				sample_prob / 10, sample_prob % 10,
+				mts->sample_power,
+				mts->ref_succ_hist,
+				mts->ref_att_hist,
+				ref_prob / 10, ref_prob % 10,
+				mts->reference_power,
+				mts->data_success,
+				mts->data_attempts,
+				data_prob / 10, data_prob % 10,
+				mts->sample_power + TPC_SAMPLE_POWER_SPAN,
+				mi->tpc_ack_txpower);
 		p += sprintf(p, "%d,%d,%d.%d\n",
 				max(0, (int) mi->total_packets -
 				(int) mi->sample_packets),
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -17,6 +17,7 @@
 #include "sta_info.h"
 #include "rc80211_minstrel.h"
 #include "rc80211_minstrel_ht.h"
+#include "tpc80211_blues.h"
 
 #define AVG_AMPDU_SIZE	16
 #define AVG_PKT_SIZE	1200
@@ -45,15 +46,6 @@
 #define BW_40			1
 #define BW_80			2
 
-/*
- * Define group sort order: HT40 -> SGI -> #streams
- */
-#define GROUP_IDX(_streams, _sgi, _ht40)	\
-	MINSTREL_HT_GROUP_0 +			\
-	MINSTREL_MAX_STREAMS * 2 * _ht40 +	\
-	MINSTREL_MAX_STREAMS * _sgi +	\
-	_streams - 1
-
 /* MCS rate information for an MCS group */
 #define MCS_GROUP(_streams, _sgi, _ht40)				\
 	[GROUP_IDX(_streams, _sgi, _ht40)] = {				\
@@ -74,12 +66,6 @@
 	}								\
 }
 
-#define VHT_GROUP_IDX(_streams, _sgi, _bw)				\
-	(MINSTREL_VHT_GROUP_0 +						\
-	 MINSTREL_MAX_STREAMS * 2 * (_bw) +				\
-	 MINSTREL_MAX_STREAMS * (_sgi) +				\
-	 (_streams) - 1)
-
 #define BW2VBPS(_bw, r3, r2, r1)					\
 	(_bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)
 
@@ -245,26 +231,6 @@ minstrel_get_valid_vht_rates(int bw, int
 	return 0x3ff & ~mask;
 }
 
-/*
- * Look up an MCS group index based on mac80211 rate information
- */
-static int
-minstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)
-{
-	return GROUP_IDX((rate->idx / 8) + 1,
-			 !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
-			 !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));
-}
-
-static int
-minstrel_vht_get_group_idx(struct ieee80211_tx_rate *rate)
-{
-	return VHT_GROUP_IDX(ieee80211_rate_get_vht_nss(rate),
-			     !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
-			     !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) +
-			     2*!!(rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH));
-}
-
 static struct minstrel_rate_stats *
 minstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 		      struct ieee80211_tx_rate *rate)
@@ -272,10 +238,10 @@ minstrel_ht_get_stats(struct minstrel_pr
 	int group, idx;
 
 	if (rate->flags & IEEE80211_TX_RC_MCS) {
-		group = minstrel_ht_get_group_idx(rate);
+		group = blues_ht_get_group_idx(rate);
 		idx = rate->idx % 8;
 	} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
-		group = minstrel_vht_get_group_idx(rate);
+		group = blues_vht_get_group_idx(rate);
 		idx = ieee80211_rate_get_vht_mcs(rate);
 	} else {
 		group = MINSTREL_CCK_GROUP;
@@ -714,7 +680,12 @@ minstrel_ht_tx_status(void *priv, struct
 	struct minstrel_ht_sta *mi = &msp->ht;
 	struct ieee80211_tx_rate *ar = info->status.rates;
 	struct minstrel_rate_stats *rate;
+	struct blues_tpc_stats *tpc;
 	struct minstrel_priv *mp = priv;
+	const s8 txpower[IEEE80211_TX_MAX_RATES] = {st->txpower[0],
+						    st->txpower[1],
+						    st->txpower[2],
+						    st->txpower[3]};
 	bool last, update = false;
 	int i;
 
@@ -736,20 +707,59 @@ minstrel_ht_tx_status(void *priv, struct
 	mi->ampdu_packets++;
 	mi->ampdu_len += info->status.ampdu_len;
 
-	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
-		mi->sample_packets += info->status.ampdu_len;
+	/* count minstrel & blues sampling probes */
+	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) {
+		tpc = blues_ht_get_stats(mp, mi, &ar[0]);
+		printk(KERN_ERR "minstrel_ht_tx_status(): "
+				"txpower[0] = %d  "
+				"tpc->reference_power = %d  "
+				"tpc->sample_power = %d\n",
+				txpower[0], tpc->reference_power,
+				tpc->sample_power);
+		if (txpower[0] == tpc->reference_power) {
+			mi->sample_packets += info->status.ampdu_len;
+			tpc->reference_attempts += info->status.ampdu_len;
+		}
+		if (txpower[0] == tpc->sample_power)
+			tpc->sample_attempts += info->status.ampdu_len;
+	}
 
+	/* count data packet attempts & successful acknowledges ones */
 	last = !minstrel_ht_txstat_valid(mp, &ar[0]);
 	for (i = 0; !last; i++) {
 		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
 		       !minstrel_ht_txstat_valid(mp, &ar[i + 1]);
 
 		rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
+		tpc  = blues_ht_get_stats(mp, mi, &ar[i]);
 
-		if (last)
-			rate->success += info->status.ampdu_ack_len;
-
-		rate->attempts += ar[i].count * info->status.ampdu_len;
+		/* successfully acknowledged packets */
+		if (last) {
+			if (txpower[i] == tpc->reference_power) {
+				tpc->reference_success += info->status.ampdu_len;
+				rate->success += info->status.ampdu_ack_len;
+			}
+			if (txpower[i] == tpc->sample_power + TPC_SAMPLE_POWER_SPAN) {
+				tpc->data_success += info->status.ampdu_len;
+				tpc->reference_success += info->status.ampdu_len;
+				rate->success += info->status.ampdu_ack_len;
+			}
+			if (txpower[i] == tpc->sample_power) {
+				tpc->sample_success += info->status.ampdu_len;
+				tpc->data_success += info->status.ampdu_len;
+				tpc->reference_success += info->status.ampdu_len;
+				rate->success += info->status.ampdu_ack_len;
+			}
+		}
+		/* unacknowledged packets */
+		if (txpower[i] == tpc->reference_power) {
+			rate->attempts += ar[i].count * info->status.ampdu_len;
+			tpc->reference_attempts += info->status.ampdu_len;
+		}
+		if (txpower[i] == tpc->sample_power + TPC_SAMPLE_POWER_SPAN)
+			tpc->data_attempts += info->status.ampdu_len;
+		if (txpower[i] == tpc->sample_power)
+			tpc->sample_attempts += info->status.ampdu_len;
 	}
 
 	/*
@@ -1125,6 +1135,7 @@ minstrel_ht_get_rate(void *priv, struct
 	struct minstrel_ht_sta_priv *msp = priv_sta;
 	struct minstrel_ht_sta *mi = &msp->ht;
 	struct minstrel_priv *mp = priv;
+	struct blues_tpc_stats *tpc;
 	int max_r, s_group, s_idx, i, random_skipp;
 	int sample_rate = -1;
 	bool mrr_capable = false;
@@ -1161,7 +1172,7 @@ minstrel_ht_get_rate(void *priv, struct
 	mi->total_packets++;
 
 	/* wraparound */
-	if (mi->total_packets == ~0) {
+	if (mi->total_packets == ~0){
 		mi->total_packets = 0;
 		mi->sample_packets = 0;
 	}
@@ -1169,9 +1180,9 @@ minstrel_ht_get_rate(void *priv, struct
 	mrr_capable = mp->has_mrr && !txrc->rts && !txrc->bss_conf->use_cts_prot;
 
 	if (unlikely(minstrel_ht_requires_sampling(mi, mp, mrr_capable))) {
-
 		/* generate random packet skip interval */
-		random_skipp = (u32)(((u64) prandom_u32() * RATE_SAMPLING_INT) >> 32);
+		random_skipp = (u32)(((u64) prandom_u32() *
+					RATE_SAMPLING_INT) >> 32);
 
 		/* find rate that is worth sampling */
 		max_r = MCS_GROUP_RATES * ARRAY_SIZE(minstrel_mcs_groups) + 1;
@@ -1183,43 +1194,64 @@ minstrel_ht_get_rate(void *priv, struct
 			else
 				break;
 		}
-
 		/* if no sampling rate is found, skip sampling attempt */
 		if (i == 0)
 			return;
-
-		/* annotate rate sampling with selected rate */
-		s_idx = sample_rate % MCS_GROUP_RATES;
-		s_group = sample_rate / MCS_GROUP_RATES;
-		mi->groups[s_group].rc_stats[s_idx].sample_skipped = 0;
-		sampling_setup = &info->control.rates[0];
-		mi->sample_packets++;
 		info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-
-		/* assign proper sampling parameters */
-		sampling_setup->count = 1;
-		if (minstrel_mcs_groups[s_group].flags & IEEE80211_TX_RC_MCS) {
-			sample_rate_group = &minstrel_mcs_groups[s_group];
-			sampling_setup->idx = s_idx +
-					(sample_rate_group->streams - 1) * 8;
-			sampling_setup->flags =minstrel_mcs_groups[s_group].flags;
-			return;
-		} else if (minstrel_mcs_groups[s_group].flags
-			   & IEEE80211_TX_RC_VHT_MCS) {
-			ieee80211_rate_set_vht(sampling_setup, s_idx,
-					  minstrel_mcs_groups[s_group].streams);
-			sampling_setup->flags = minstrel_mcs_groups[s_group].flags;
-			return;
+	} else if (unlikely(blues_ht_requires_sampling(mi, mp, mrr_capable))) {
+		/* Blues sampling for TPC */
+		sample_rate = blues_ht_get_next_sample_rate(mi);
+
+		/* keep a balanced sampling between tpc_ref and tpc_sample */
+		tpc = &mi->groups[sample_rate / MCS_GROUP_RATES].tpc_stats[
+						sample_rate % MCS_GROUP_RATES];
+		if (tpc->reference_attempts > tpc->sample_attempts) {
+			info->control.txpower = tpc->sample_power;
+			printk(KERN_ERR "tpc_sample sampling! \
+					 tpc->reference_attempts= %d \
+					 tpc->sample_attempts = %d\n",
+					 tpc->reference_attempts,
+					 tpc->sample_attempts);
 		} else {
-			int idx = sample_rate % ARRAY_SIZE(mp->cck_rates);
-			sampling_setup->idx = mp->cck_rates[idx];
-			sampling_setup->flags = 0;
-			return;
+			info->control.txpower = tpc->reference_power;
+			printk(KERN_ERR "tpc_reference sampling! \
+					 tpc->reference_attempts= %d \
+					 tpc->sample_attempts = %d\n",
+					 tpc->reference_attempts,
+					 tpc->sample_attempts);
 		}
+		info->flags |= IEEE80211_TX_CTL_TPC_PROBE;
+
+		/* set RATE_CTRL_PROBE flag to use unaggregated tpc probes */
+		info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
 	} else {
 		 /* no rate sampling required */
 		 return;
 	}
+
+	/* assign proper sampling parameters */
+	s_idx = sample_rate % MCS_GROUP_RATES;
+	s_group = sample_rate / MCS_GROUP_RATES;
+	mi->groups[s_group].rc_stats[s_idx].sample_skipped = 0;
+	mi->sample_packets++;
+	sampling_setup = &info->control.rates[0];
+	sampling_setup->count = 1;
+	if (minstrel_mcs_groups[s_group].flags & IEEE80211_TX_RC_MCS) {
+		sample_rate_group = &minstrel_mcs_groups[s_group];
+		sampling_setup->idx = s_idx + (sample_rate_group->streams - 1) * 8;
+		sampling_setup->flags =minstrel_mcs_groups[s_group].flags;
+		return;
+	} else if (minstrel_mcs_groups[s_group].flags & IEEE80211_TX_RC_VHT_MCS) {
+		ieee80211_rate_set_vht(sampling_setup, s_idx,
+				       minstrel_mcs_groups[s_group].streams);
+		sampling_setup->flags = minstrel_mcs_groups[s_group].flags;
+		return;
+	} else {
+		int idx = sample_rate % ARRAY_SIZE(mp->cck_rates);
+		sampling_setup->idx = mp->cck_rates[idx];
+		sampling_setup->flags = 0;
+		return;
+	}
 }
 
 static void
@@ -1413,9 +1445,14 @@ minstrel_ht_rate_init(void *priv, struct
                       struct ieee80211_sta *sta, void *priv_sta)
 {
 	struct minstrel_ht_sta_priv *msp = priv_sta;
+	struct minstrel_priv *mp = priv;
 
 	minstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);
 	msp->ht.last_rate_update = jiffies;
+	msp->ht.last_tpc_update = jiffies;
+
+	/* Blues tpc initialization per rate */
+	blues_ht_tpc_init(mp, msp);
 }
 
 static void
@@ -1434,6 +1471,7 @@ minstrel_ht_alloc_sta(void *priv, struct
 	struct minstrel_ht_sta_priv *msp;
 	struct minstrel_priv *mp = priv;
 	struct ieee80211_hw *hw = mp->hw;
+	s8 max_power_level = hw->conf.power_level;
 	int max_rates = 0;
 	int i;
 
@@ -1455,6 +1493,11 @@ minstrel_ht_alloc_sta(void *priv, struct
 	if (!msp->sample_table)
 		goto error1;
 
+	/* Initialize Blues txpower for ACK packets */
+	blues_set_ack_power(hw, max_power_level);
+	printk(KERN_ERR "Ack_power initialized to = %i dBm\n",
+						hw->conf.ack_txpower);
+
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	msp->fixed_txpower = (u8) -1;
 	msp->fixed_txrate = (u32) -1;
--- /dev/null
+++ b/net/mac80211/common.c
@@ -0,0 +1,22 @@
+/*
+ * Transmit Power Control (TPC) algorithm "MINSTREL-BLUES".
+ * ________________________________________________________________________
+ * A decentralized joint power and rate controller that maximizes the weighted
+ * utility of achievable throughput and interference. Power and rate per link
+ * (per packet) are controlled to replace current static tx power usage. The
+ * goal is to increase overall WiFi network performance by increasing spatial
+ * reuse and hence allow more active links to communicate in parallel. Hence
+ * shared spectrum is used more efficiently by avoiding unnecessary
+ * interference through dynamic joint power and rate control.
+ *
+ * Copyright (C) 2016  Thomas Huehn <thomas@net.t-labs.tu-berlin.de>
+ *                     Denis Roeper <denis.roeper@posteo.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include "common.h"
+
--- /dev/null
+++ b/net/mac80211/common.h
@@ -0,0 +1,130 @@
+/*
+ * Transmit Power Control (TPC) algorithm "MINSTREL-BLUES".
+ * ________________________________________________________________________
+ * A decentralized joint power and rate controller and hepcat that plays as
+ * loud as thourghput vs. interference is weighted. Power and rate per link
+ * (per packet) is under its control to replace static WiFi shouting with
+ * dynamic use and interplay. The big goal is to increase overall network
+ * performance by increasing spatial reuse, more active links in parallel.
+ *
+ * Copyright (C) 2017  Thomas Huehn <thomas@net.t-labs.tu-berlin.de>
+ *                     Denis Roeper <denis.roeper@posteo.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef __MINSTREL_BLUES_COMMON_H
+#define __MINSTREL_BLUES_COMMON_H
+
+#include <net/mac80211.h>
+
+/*
+ * The number of streams can be changed to 2 to reduce code
+ * size and memory footprint.
+ */
+#define MINSTREL_MAX_STREAMS		3
+#define MINSTREL_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+#define MINSTREL_VHT_STREAM_GROUPS	6 /* BW(=3) * SGI(=2) */
+#else
+#define MINSTREL_VHT_STREAM_GROUPS	0
+#endif
+
+#define MINSTREL_HT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
+				 MINSTREL_HT_STREAM_GROUPS)
+#define MINSTREL_VHT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
+				 MINSTREL_VHT_STREAM_GROUPS)
+#define MINSTREL_CCK_GROUPS_NB	1
+#define MINSTREL_GROUPS_NB	(MINSTREL_HT_GROUPS_NB +	\
+				 MINSTREL_VHT_GROUPS_NB +	\
+				 MINSTREL_CCK_GROUPS_NB)
+
+#define MINSTREL_HT_GROUP_0	0
+#define MINSTREL_CCK_GROUP	(MINSTREL_HT_GROUP_0 + MINSTREL_HT_GROUPS_NB)
+#define MINSTREL_VHT_GROUP_0	(MINSTREL_CCK_GROUP + 1)
+
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+#define MCS_GROUP_RATES		10
+#else
+#define MCS_GROUP_RATES		8
+#endif
+
+/*
+ * Define group sort order: HT40 -> SGI -> #streams
+ */
+#define GROUP_IDX(_streams, _sgi, _ht40)        \
+	MINSTREL_HT_GROUP_0 +                   \
+	MINSTREL_MAX_STREAMS * 2 * _ht40 +      \
+	MINSTREL_MAX_STREAMS * _sgi +   \
+	_streams - 1
+
+#define VHT_GROUP_IDX(_streams, _sgi, _bw)	\
+	(MINSTREL_VHT_GROUP_0 +			\
+	MINSTREL_MAX_STREAMS * 2 * (_bw) +	\
+	MINSTREL_MAX_STREAMS * (_sgi) +		\
+	(_streams) - 1)
+
+struct minstrel_rate_stats {
+	/* current / last sampling period attempts/success counters */
+	u16 attempts, last_attempts;
+	u16 success, last_success;
+
+	/* total attempts/success counters */
+	u32 att_hist, succ_hist;
+
+	/* statistis of packet delivery probability
+	 *  prob_ewma - exponential weighted moving average of prob
+	 *  prob_ewmsd - exp. weighted moving standard deviation of prob */
+	u16 prob_ewma;
+	u16 prob_ewmv;
+
+	/* maximum retry counts */
+	u8 retry_count;
+	u8 retry_count_rtscts;
+
+	u8 sample_skipped;
+	bool retry_updated;
+};
+
+struct blues_tpc_stats {
+	/* per rate tpc values */
+	u16 reference_success, reference_attempts;
+	u16 data_success, data_attempts;
+	u16 sample_success, sample_attempts;
+	u16 reference_prob, data_prob, sample_prob;
+	u32 ref_succ_hist, ref_att_hist;
+	u32 sample_succ_hist, sample_att_hist;
+	s8 reference_power, sample_power;
+	u8 stats_outdated;
+};
+
+
+//static int
+//blues_ht_get_group_idx(struct ieee80211_tx_rate *rate);
+
+//static int
+//blues_vht_get_group_idx(struct ieee80211_tx_rate *rate);
+
+/*
+ * Look up an MCS group index based on mac80211 rate information
+ */
+static int
+blues_ht_get_group_idx(struct ieee80211_tx_rate *rate)
+{
+	return GROUP_IDX((rate->idx / 8) + 1,
+			 !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
+			 !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));
+}
+
+static int
+blues_vht_get_group_idx(struct ieee80211_tx_rate *rate)
+{
+	return VHT_GROUP_IDX(ieee80211_rate_get_vht_nss(rate),
+			     !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
+			     !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) +
+			     2*!!(rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH));
+}
+#endif
